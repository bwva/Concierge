Concierge.pm
============
# Installation of a Standard Concierge:
	my $storage_dir			= 'path/to/storage_dir';			# For both Sessions and Users
	my $auth_file			= 'path/to/passwordfile';			# Put in $storage_dir if only filename
	my $app_fields			= []; # app-specified fields to add to user database
	my $user_session_fields	= []; # app-specified fields for use with $session->set_data() & $session->get_data()

	my $installation_result = Concierge->build_desk( $storage_dir, $auth_file, $app_fields, $user_session_fields );

    sub build_desk ($storage_dir, $auth_file, $app_fields=[], $user_session_fields)=[] (
    	my $self = Concierge->new(); 	# minimal object
    	
        $self->{sessions}	= Concierge::Sessions->new( { 
        	storage_dir 		=> $storage_dir,				# required
        	backend 			=> '', 							# use default ('SQLite')
        	session_timeout		=> '',							# use default (3600)
        } );
        my $session			= $self->{sessions}->new_session( user_id => '__concierge__' );
        
        $self->{user_session_fields}	= $user_session_fields;	# optional, specified by app

        $self->{auth} 		=	Concierge::Auth->new ({ 
        	auth_file 			=> $auth_file		 			# required
        });
		my $users_setup		= Concierge::Users->setup( { 
        	storage_dir 		=> $storage_dir,				# required
        	backend 			=> '',							# use default ('database')
        	include_standard_fields => 'all', 					# use standard
        	field_overrides 	=> [],							# use standard
        	app_fields 			=> $app_fields,					# optional, specified by app
        });
		return unless $users_setup->{success};

        my $full_config	= { 
        	users_config_file	=> $users_setup->{config_file},
        	storage_dir 		=> $storage_dir,
        	auth_file			=> $auth_file,
        	user_session_fields	=> $user_session_fields,
        };
        
        my $concierge_session_data	= {
        	concierge_config	=> $full_config,
        	user_keys			=> {},
        };
        $session->set_data($concierge_session_data)
        $session->save();
        
        return { success => 1, message => "Ready!", desk => $storage_dir };
    );

# Result from Installation with Concierge->build_desk():
	# $installation_result = { success => 1|0, message => "...", desk => 'path/to/storage_dir' }
	# Dies on fail
	# If success:
	# Stored Concierge session with config for instantiating $concierge:
		# sessions: session_storage_dir, backend 	# no change after installation
		# auth: password file path					# no change after installation
		# users: config file path					# no change after installation
		# user_key: user_id <=> session_id lookups	# updated when sessions added/deleted 
		# user_session_fields: 						# used with session data

# Operations with Installed Concierge
	# get the concierge desk location from somewhere...
	my $desk_location	= $installation_result->{desk} || $app->config->{concierge}->{desk};
	sub open_desk ($desk_location) {
		croak unless -d $desk_location;
		# Instantiate the concierge from config stored in Concierge's session data
		my $instantiated_concierge;
		$instantiated_concierge->{sessions}	= Concierge::Sessions->new( storage_dir => $desk_location );
		my $concierge_session	= $instantiated_concierge->{sessions}->get_session('__concierge__');
		my $concierge_config	= $concierge_session->get_data()->{concierge_config};
		# Instantiate users and auth from $concierge_config
		$instantiated_concierge->{users}	= Concierge::Users->new( $concierge_config->{users_config_file} );
		$instantiated_concierge->{auth}		= Concierge::Auth->new( $concierge_config->{auth_file} )

		return { success => 1, message => 'Welcome!', concierge => $instantiated_concierge };
	}
	my $desk_is_open	= Concierge->open_desk( $desk_location ); 
	my $concierge		= $desk_is_open->{concierge} if $desk_is_open->{success};
	# Instantiated Concierge object $concierge
		# Has own session
		# Has Sessions Manager
		# Has User Data Interface
		# Has User Authenticator
	

Users.pm
========
* setup API
setup
* admin 
new	[users manager]
list_users
* user management API
register_user
get_user
update_user
delete_user
#===============

Auth.pm
=======
* setup/admin
new
pfile
setFile
clearFile
rmFile
* operational API
setPwd
checkPwd
resetPwd
checkID
deleteID

* response encapsulation - Class methods - Not Public API
confirm
reject
reply

* utilities - Not Public API
validateFile
validateID
validatePwd
encryptPwd

* generators - Not Public API via Concierge
gen_crypt_token
gen_random_string
gen_random_token
gen_token
gen_uuid
gen_word_phrase
#===============

Sessions.pm
===========
* setup
new
* admin API
new	[session manager]
cleanup_expired
delete_session
delete_user_sessions
* session API
new_session
get_session

#===============

Session.pm
==========
* session API
new
get_data
set_data
save

* status API (read-only)
is_active
is_dirty
is_expired
is_valid

* metadata API (read-only)
session_id
status
created_at
expires_at
last_updated
storage_backend


